#!/bin/sh
# create-zig-app â€“ a lean Zig project initializer
# https://github.com/hiimsergey/create-zig-app

set -eu

text_mainfile=""
text_allocator_1=""
text_allocator_2=""
text_allocator_3=""

echo_main_zig() {
	echo -e "const std = @import(\"std\");$text_allocator_1
pub fn main() void {$text_allocator_2
	std.debug.print(\"Hello, world!\\\\n\", .{});
}"
}

echo_allocator_zig() {
	echo -e "const builtin = @import(\"builtin\");
const std = @import(\"std\");

/// Comptime wrapper that resolves to the slow but helpful \`DebugAllocator\` in
/// Debug mode and the performant but dangerous \`c_allocator\` in all the other modes.
pub const AllocatorWrapper = if (builtin.mode == .Debug) struct {
	const Self = @This();
	const DebugAllocator = std.heap.DebugAllocator(.{});

	dbg_state: DebugAllocator,

	/// Initializes Zig's \`DebugAllocator\`.
	pub inline fn init() Self {
		return .{ .dbg_state = DebugAllocator.init };
	}

	/// Returns the \`DebugAllocator\`'s allocator.
	pub inline fn allocator(self: *Self) std.mem.Allocator {
		return self.dbg_state.allocator();
	}

	/// Deinits Zig's \`DebugAllocator\` and log an error message if
	/// the program contains Zig-side memory leaks.
	pub inline fn deinit(self: *Self) void {
		if (self.dbg_state.deinit() == .leak)
			std.debug.print(\"ERROR: Leaks found!\", .{});
	}
} else struct {
	const Self = @This();

	/// Trivial struct initialization.
	pub inline fn init() Self { return .{}; }

	/// Simply returns \`@import(\"std\").heap.c_allocator\`.
	pub inline fn allocator(_: *Self) std.mem.Allocator {
		return std.heap.c_allocator;
	}

	/// NOP function.
	pub inline fn deinit(_: *Self) void {}
};"
}

echo_build_zig() {
	echo -e "const Build = @import(\"std\").Build;

// Latest Zig version as of writing this: $(zig version)
pub fn build(b: *Build) void {
	// Options
	const target = b.standardTargetOptions(.{});
	const optimize = b.standardOptimizeOption(.{});

	// Executable declaration
	const exe = b.addExecutable(.{
		.name = \"$text_projname\",
		.root_module = b.createModule(.{
			.root_source_file = b.path(\"$text_mainfile\"),
			.target = target,
			.optimize = optimize
		})
	});$text_allocator_3

	// Actual installation
	b.installArtifact(exe);$text_runstep
}"
}

ask() { printf "\x1b[39;1m$1\x1b[0m"; }

error() { printf "\x1b[31m$1\x1b[39m\n"; }

success() { printf "\x1b[32m$1\x1b[39m\n"; }

set_code() { printf "\x1b[36m"; }
set_normal() { printf "\x1b[39m"; }

while true; do
	ask "What to name your Zig project? "
	read text_projname
	case "$text_projname" in
		"")
			error "The input has to be non-empty!"
			;;
		*)
			if [ -d "$text_projname" ]; then
				error "'$text_projname' already exists!"
				continue
			fi
			break
			;;
	esac
done

mkdir "$text_projname"
cd "$text_projname"
trap "cd ..; rm -frv '$text_projname'" SIGINT

while true; do
	ask "Do you want a dedicated src/ directory? [Y/n] "
	read yn_srcdir
	case "$yn_srcdir" in
		""|[y/Y]|[y/Y][e/E][s/S])
			mkdir "src"
			text_mainfile="src/main.zig"
			text_allocator_zig="src/allocator.zig"
			break
			;;
		[n/N]|[n/N][o/O])
			text_mainfile="$text_projname.zig"
			text_allocator_zig="allocator.zig"
			break
			;;
		*)
			error "Invalid response!"
			;;
	esac
done

while true; do
	ask "Do you want a run step in the build.zig? [Y/n] "
	read yn_runstep
	case "$yn_runstep" in
		""|[y/Y]|[y/Y][e/E][s/S])
			text_runstep="\n\n\t// Run command
	const run_exe = b.addRunArtifact(exe);
	const run_step = b.step(\"run\", \"Run the program\");
	run_step.dependOn(&run_exe.step);\n"
			break
			;;
		[n/N]|[n/N][o/O])
			text_runstep=""
			break
			;;
		*)
			error "Invalid response!"
			;;
	esac
done

while true; do
	ask "Do you want the allocator wrapper struct? [y/N/help] "
	read yn_allocator
	case "$yn_allocator" in
		[y/Y]|[y/Y][e/E][s/S])
			echo_allocator_zig > "$text_allocator_zig"
			text_allocator_1="\nconst AllocatorWrapper = @import(\"allocator.zig\").AllocatorWrapper;\n"
			text_allocator_2="\n\tvar aw = AllocatorWrapper.init();
	defer aw.deinit();

	const allocator = aw.allocator();
	_ = allocator;\n"
			text_allocator_3="\n\n\texe.linkLibC(); // Needed for \`std.heap.c_allocator\`"
			break
			;;
		""|[n/N]|[n/N][o/O])
			break
			;;
		[h/H]|[h/H][e/E][l/L][p/P])
			set_code
			echo_allocator_zig
			set_normal
			echo -e "\nThis is a struct I wrote that uses the debugging allocator (slower but tracks memory leaks)
when compiling in Debug mode and the C allocator (fast but doesn't track memory leaks)
otherwise. This script includes how to use it:\n"
			set_code
			echo -e "var aw = AllocatorWrapper.init();
defer aw.deinit();
const allocator = aw.allocator();\n"
			set_normal
			;;
		*)
			error "Invalid response!"
			;;
	esac
done

echo_build_zig > "build.zig"
echo_main_zig > "$text_mainfile"

while true; do
	ask "Do you want to initialize a Git repository? [y/N] "
	read yn_gitinit
	case "$yn_gitinit" in
		[y/Y]|[y/Y][e/E][s/S])
			git init
			echo -e ".zig-cache/\nzig-out/" > ".gitignore"
			b_gitcommit="true"
			break
			;;
		""|[n/N]|[n/N][o/O])
			b_gitcommit="false"
			break
			;;
		*)
			error "Invalid response!"
			;;
	esac
done

while [ $b_gitcommit = "true" ]; do
	ask "Do you want to commit right away? [y/N] "
	read yn_gitcommit
	case "$yn_gitcommit" in
		[y/Y]|[y/Y][e/E][s/S])
			git add .
			git commit -m "Initial commit"
			break
			;;
		""|[n/N]|[n/N][o/O])
			break
			;;
		*)
			error "Invalid response!"
			;;
	esac
done

success "Done!"
